// Jenkinsfile para construir y desplegar una aplicación .NET en OpenShift usando Source-to-Image (S2I)
// Este pipeline ahora se ejecutará en un Pod de Kubernetes provisionado dinámicamente.

pipeline {
    agent {
        kubernetes {
            // Cloud (optional): If you have multiple Kubernetes clouds configured in Jenkins,
            // specify the name here, e.g., cloud 'openshift'
            // namespace (optional): The Kubernetes namespace where the Pod will be created.
            // Defaults to the namespace where the Jenkins agent itself is running,
            // or the one configured in the Jenkins Kubernetes plugin.
            // namespace 'your-build-namespace'

            // Define the container template for the Pod
            // We need a base image that has 'oc' and 'git' installed.
            // The dotnet build will be handled by OpenShift S2I, so we don't need dotnet SDK here.
            containerTemplate {
                name 'build'
                image 'openshift/origin-cli:latest' // Or your custom image with 'oc' and 'git'
                command 'cat'
                ttyEnabled true
                # cpu '500m' // Optional: Request CPU
                # memory '1Gi' // Optional: Request Memory
            }
            // Optional: If you need to mount a volume, for example, for shared cache or kubeconfig
            # yaml """
            #   apiVersion: v1
            #   kind: Pod
            #   spec:
            #     containers:
            #     - name: build
            #       volumeMounts:
            #       - mountPath: /var/run/docker.sock # Example for Docker-in-Docker if needed (not for S2I)
            #         name: docker-sock
            #     volumes:
            #     - name: docker-sock
            #       hostPath:
            #         path: /var/run/docker.sock
            # """
        }
    }

    // Parámetros configurables para el pipeline
    parameters {
        string(name: 'OPENSHIFT_PROJECT', defaultValue: '${{ values.repoName }}', description: 'Nombre del proyecto de OpenShift donde se desplegará la aplicación.')
        string(name: 'APP_NAME', defaultValue: '${{ values.repoName }}', description: 'Nombre de la aplicación y del ImageStream/DeploymentConfig.')
        string(name: 'GIT_REPO_URL', defaultValue: 'https://${{ values.sourceControl }}/${{ values.orgName }}/${{ values.repoName }}', description: 'URL del repositorio Git de la aplicación.')
        string(name: 'GIT_BRANCH', defaultValue: 'main', description: 'Rama de Git a construir.')
    }

    stages {
        stage('Login to OpenShift') {
            steps {
                script {
                    // When running in a Kubernetes Pod, the 'oc' CLI often needs to authenticate.
                    // If Jenkins itself is running inside OpenShift and has a ServiceAccount
                    // with appropriate permissions, 'oc login' might not be strictly necessary,
                    // or it might auto-authenticate.
                    // However, it's good practice to ensure the project is set.
                    sh "oc project ${OPENSHIFT_PROJECT}"
                    echo "Logged into OpenShift project: ${OPENSHIFT_PROJECT}"
                }
            }
        }

        stage('Apply OpenShift S2I Resources') {
            steps {
                script {
                    sh "oc apply -f openshift/image-stream.yaml -n ${OPENSHIFT_PROJECT}"
                    sh "oc apply -f openshift/build-config.yaml -n ${OPENSHIFT_PROJECT}"
                    sh "oc apply -f openshift/service.yaml -n ${OPENSHIFT_PROJECT}"
                    sh "oc apply -f openshift/deployment-config.yaml -n ${OPENSHIFT_PROJECT}"
                    sh "oc apply -f openshift/route.yaml -n ${OPENSHIFT_PROJECT}"
                    echo "OpenShift resources applied."
                }
            }
        }

        stage('Start S2I Build') {
            steps {
                script {
                    // OpenShift will clone the Git repo directly from the BuildConfig.
                    // The build pod will be managed by OpenShift itself, not this Jenkins agent pod.
                    sh "oc start-build ${APP_NAME} --from-repo=${GIT_REPO_URL} --follow -n ${OPENSHIFT_PROJECT} --wait"
                    echo "OpenShift S2I build started and completed for ${APP_NAME}."
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    sh "oc rollout status dc/${APP_NAME} -n ${OPENSHIFT_PROJECT}"
                    echo "Deployment for ${APP_NAME} is complete."

                    def routeUrl = sh(script: "oc get route ${APP_NAME} -o jsonpath='{.spec.host}' -n ${OPENSHIFT_PROJECT}", returnStdout: true).trim()
                    echo "Application URL: http://${routeUrl}"
                }
            }
        }
    }

    post {
        always {
            cleanWs() // Cleans the Jenkins workspace (the ephemeral Pod)
        }
        failure {
            echo "Pipeline failed. Check logs for details."
        }
        success {
            echo "Pipeline completed successfully!"
        }
    }
}